<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dual Path Grid ‚Äî 21x4 (Horizontal)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    body {
      font-family: 'Inter', sans-serif;
    }
    
    .cell {
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .cell:hover {
      transform: scale(1.05);
    }
    
    .cell.path1 {
      background: linear-gradient(135deg, #10b981, #06b6d4);
      box-shadow: 0 8px 20px rgba(6, 182, 212, 0.3);
    }
    
    .cell.path2 {
      background: linear-gradient(135deg, #f59e0b, #f97316);
      box-shadow: 0 8px 20px rgba(249, 115, 22, 0.3);
    }
    
    .cell.start1 {
      animation: pulse1 2s infinite;
    }
    
    .cell.start2 {
      animation: pulse2 2s infinite;
    }
    
    @keyframes pulse1 {
      0%, 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
      50% { box-shadow: 0 0 0 8px rgba(16, 185, 129, 0); }
    }
    
    @keyframes pulse2 {
      0%, 100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); }
      50% { box-shadow: 0 0 0 8px rgba(245, 158, 11, 0); }
    }
    
    .cell.finish1 {
      animation: glow1 2s infinite;
    }
    
    .cell.finish2 {
      animation: glow2 2s infinite;
    }
    
    @keyframes glow1 {
      0%, 100% { box-shadow: 0 0 0 0 rgba(6, 182, 212, 0.7); }
      50% { box-shadow: 0 0 0 8px rgba(6, 182, 212, 0); }
    }
    
    @keyframes glow2 {
      0%, 100% { box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.7); }
      50% { box-shadow: 0 0 0 8px rgba(249, 115, 22, 0); }
    }
    
    .gradient-bg {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .glass-effect {
      backdrop-filter: blur(10px);
      background: rgba(15, 23, 42, 0.8);
    }
    
    /* HORIZONTAL GRID - Main change here! */
    #grid-container {
      display: grid;
      grid-template-rows: repeat(4, 1fr);
      grid-template-columns: repeat(21, 1fr);
      gap: 0.5rem;
    }
    
    .col-label {
      writing-mode: horizontal-tb;
    }
  </style>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#10b981',
            secondary: '#06b6d4',
          }
        }
      }
    }
  </script>
</head>
<body class="bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 min-h-screen">
  
  <!-- Header -->
  <div class="container mx-auto px-4 py-6">
    <div class="text-center mb-8">
      <h1 class="text-5xl font-bold text-white mb-3 tracking-tight">
        üé≤ Dual Path Generator (Horizontal View)
      </h1>
      <p class="text-slate-300 text-lg">Generate 2 jalur independen dalam 21√ó4 grid - TAMPILAN MENYAMPING</p>
    </div>
  </div>

  <!-- Main Content -->
  <div class="container mx-auto px-4 pb-10">
    
    <!-- Controls Section -->
    <div class="glass-effect rounded-2xl p-6 shadow-2xl border border-slate-700 mb-6">
      <div class="grid md:grid-cols-2 lg:grid-cols-5 gap-4">
        <!-- Button Generate -->
        <button id="gen" class="bg-gradient-to-r from-emerald-500 to-teal-500 hover:from-emerald-600 hover:to-teal-600 text-white font-semibold py-3 px-6 rounded-xl shadow-lg transform hover:scale-105 transition-all duration-200">
          üé≤ Generate Dual Paths
        </button>
        
        <!-- Settings -->
        <label class="flex items-center gap-3 cursor-pointer group bg-slate-800/50 rounded-lg px-4">
          <input id="prefer-middle" type="checkbox" checked class="w-5 h-5 text-emerald-500 bg-slate-700 border-slate-600 rounded focus:ring-2 focus:ring-emerald-500 focus:ring-offset-0 cursor-pointer" />
          <span class="text-slate-200 group-hover:text-white transition-colors text-sm">Prefer middle start</span>
        </label>
        
        <label class="flex items-center gap-3 cursor-pointer group bg-slate-800/50 rounded-lg px-4">
          <input id="more-turns" type="checkbox" class="w-5 h-5 text-emerald-500 bg-slate-700 border-slate-600 rounded focus:ring-2 focus:ring-emerald-500 focus:ring-offset-0 cursor-pointer" />
          <span class="text-slate-200 group-hover:text-white transition-colors text-sm">More turns</span>
        </label>
        
        <label class="flex items-center gap-3 cursor-pointer group bg-slate-800/50 rounded-lg px-4">
          <input id="balanced" type="checkbox" checked class="w-5 h-5 text-emerald-500 bg-slate-700 border-slate-600 rounded focus:ring-2 focus:ring-emerald-500 focus:ring-offset-0 cursor-pointer" />
          <span class="text-slate-200 group-hover:text-white transition-colors text-sm">Balanced</span>
        </label>
        
        <label class="flex items-center gap-3 cursor-pointer group bg-slate-800/50 rounded-lg px-4">
          <input id="avoid-collision" type="checkbox" checked class="w-5 h-5 text-emerald-500 bg-slate-700 border-slate-600 rounded focus:ring-2 focus:ring-emerald-500 focus:ring-offset-0 cursor-pointer" />
          <span class="text-slate-200 group-hover:text-white transition-colors text-sm">Avoid collision</span>
        </label>
      </div>
    </div>
    
    <!-- Grid Section - HORIZONTAL -->
    <div class="glass-effect rounded-2xl p-6 shadow-2xl border border-slate-700 mb-6">
      <h2 class="text-xl font-semibold text-white mb-4 flex items-center gap-2">
        <span class="text-2xl">üó∫Ô∏è</span> Grid Horizontal (Row = Baris Horizontal)
      </h2>
      
      <div class="bg-slate-800/50 rounded-xl p-5 overflow-x-auto">
        <div class="mb-3 flex gap-2">
          <!-- Column Labels (1-21) -->
          <div class="w-12"></div> <!-- spacer for row labels -->
          <div id="col-labels" class="flex gap-2"></div>
        </div>
        
        <!-- Grid Container -->
        <div class="flex flex-col gap-2">
          <div id="grid-rows"></div>
        </div>
      </div>
      
      <!-- Hint -->
      <div class="mt-4 text-sm text-slate-300 bg-slate-800/30 rounded-lg p-3">
        üí° <span class="font-medium">Tip:</span> Klik sel untuk toggle manual. 
        <span class="text-emerald-400 font-semibold">Path 1 (Hijau) üü¢</span> & 
        <span class="text-amber-400 font-semibold">Path 2 (Oranye) üü†</span>
      </div>
    </div>
    
    <!-- Stats & Preview -->
    <div class="grid lg:grid-cols-2 gap-6">
      <!-- Stats -->
      <div class="glass-effect rounded-2xl p-6 shadow-2xl border border-slate-700">
        <h3 class="text-lg font-semibold text-white mb-3 flex items-center gap-2">
          <span>üìà</span> Statistik
        </h3>
        <div id="stats" class="space-y-2 text-sm"></div>
      </div>
      
      <!-- Preview -->
      <div class="glass-effect rounded-2xl p-6 shadow-2xl border border-slate-700">
        <h2 class="text-xl font-semibold text-white mb-4 flex items-center gap-2">
          <span class="text-2xl">üìä</span> Preview
        </h2>
        
        <div class="bg-slate-900/70 rounded-xl p-5 border border-slate-700 overflow-hidden">
          <pre id="preview" class="text-sm text-slate-200 leading-relaxed overflow-auto max-h-[400px] font-mono"></pre>
        </div>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const ROWS = 21, COLS = 4;
    const gridRowsEl = document.getElementById('grid-rows');
    const colLabelsEl = document.getElementById('col-labels');
    const preview = document.getElementById('preview');
    const statsEl = document.getElementById('stats');
    const preferMiddle = document.getElementById('prefer-middle');
    const moreTurns = document.getElementById('more-turns');
    const balanced = document.getElementById('balanced');
    const avoidCollision = document.getElementById('avoid-collision');

    // State untuk 2 jalur: 0 = kosong, 1 = path1, 2 = path2
    let state = new Array(ROWS).fill(0).map(()=>new Array(COLS).fill(0));

    function createUI(){
      // Create column labels (1-21)
      colLabelsEl.innerHTML = '';
      for(let col=0; col<ROWS; col++){
        const label = document.createElement('div');
        label.className = 'w-12 h-8 flex items-center justify-center text-slate-400 font-semibold text-xs bg-slate-800/50 rounded-lg col-label';
        label.textContent = (col+1).toString().padStart(2,'0');
        colLabelsEl.appendChild(label);
      }
      
      // Create horizontal rows
      gridRowsEl.innerHTML = '';
      for(let row=0; row<COLS; row++){
        const rowContainer = document.createElement('div');
        rowContainer.className = 'flex gap-2 items-center';
        
        // Row label (Row 0, 1, 2, 3)
        const rowLabel = document.createElement('div');
        rowLabel.className = 'w-12 h-12 flex items-center justify-center text-slate-400 font-semibold text-xs bg-slate-800/50 rounded-lg';
        rowLabel.textContent = `R${row}`;
        rowContainer.appendChild(rowLabel);
        
        // Cells for this row
        for(let col=0; col<ROWS; col++){
          const cell = document.createElement('div');
          cell.className='cell w-12 h-12 flex items-center justify-center rounded-xl bg-slate-800/80 cursor-pointer border-2 border-transparent hover:border-slate-600 text-xl select-none';
          cell.dataset.r=col; // col is actually the "row" in original data
          cell.dataset.c=row; // row is actually the "col" in original data
          cell.addEventListener('click',()=>{
            state[col][row] = (state[col][row] + 1) % 3;
            render(); 
            updatePreview();
          });
          rowContainer.appendChild(cell);
        }
        
        gridRowsEl.appendChild(rowContainer);
      }
    }

    function render(){
      const rows = gridRowsEl.children;
      
      for(let row=0; row<COLS; row++){
        const rowEl = rows[row];
        const cells = Array.from(rowEl.children).slice(1); // skip label
        
        for(let col=0; col<ROWS; col++){
          const cell = cells[col];
          const val = state[col][row];
          
          cell.classList.remove('path1', 'path2', 'start1', 'start2', 'finish1', 'finish2');
          cell.style.outline = '';
          
          if(val === 1){
            cell.classList.add('path1');
            cell.textContent = 'üü¢';
          } else if(val === 2){
            cell.classList.add('path2');
            cell.textContent = 'üü†';
          } else {
            cell.textContent = '';
          }
        }
      }
      
      // Mark start & finish untuk path 1
      for(let col=0; col<ROWS; col++){
        for(let row=0; row<COLS; row++){
          if(state[col][row] === 1){
            const rowEl = gridRowsEl.children[row];
            const cell = rowEl.children[col + 1]; // +1 for label
            cell.classList.add('start1');
            cell.style.outline = '3px solid #10b981';
            cell.style.outlineOffset = '2px';
            cell.textContent = 'üöÄ';
            col = ROWS; break;
          }
        }
      }
      
      for(let col=ROWS-1; col>=0; col--){
        for(let row=0; row<COLS; row++){
          if(state[col][row] === 1){ 
            const rowEl = gridRowsEl.children[row];
            const cell = rowEl.children[col + 1];
            cell.classList.add('finish1');
            cell.style.outline = '3px solid #06b6d4';
            cell.style.outlineOffset = '2px';
            cell.textContent = 'üèÅ';
            col=-1; break; 
          }
        }
      }
      
      // Mark start & finish untuk path 2
      for(let col=0; col<ROWS; col++){
        for(let row=0; row<COLS; row++){
          if(state[col][row] === 2){
            const rowEl = gridRowsEl.children[row];
            const cell = rowEl.children[col + 1];
            cell.classList.add('start2');
            cell.style.outline = '3px solid #f59e0b';
            cell.style.outlineOffset = '2px';
            cell.textContent = '‚≠ê';
            col = ROWS; break;
          }
        }
      }
      
      for(let col=ROWS-1; col>=0; col--){
        for(let row=0; row<COLS; row++){
          if(state[col][row] === 2){ 
            const rowEl = gridRowsEl.children[row];
            const cell = rowEl.children[col + 1];
            cell.classList.add('finish2');
            cell.style.outline = '3px solid #f97316';
            cell.style.outlineOffset = '2px';
            cell.textContent = 'üéØ';
            col=-1; break; 
          }
        }
      }
    }

    function updatePreview(){
      const lines = state.map((row, idx)=>{
        const rowNum = (idx+1).toString().padStart(2,'0');
        const cells = row.map(cell => {
          if(cell === 1) return 'üü¢';
          if(cell === 2) return 'üü†';
          return '‚¨ú';
        }).join(' ');
        return `${rowNum}: ${cells}`;
      });
      preview.textContent = lines.join('\n');
      
      // Calculate stats
      let path1Count = 0, path2Count = 0;
      let turns1 = 0, turns2 = 0;
      let straight1 = 0, straight2 = 0;
      let lastCol1 = -1, lastCol2 = -1;
      let colCounts1 = [0,0,0,0];
      let colCounts2 = [0,0,0,0];
      let collisions = 0;
      
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(state[r][c] === 1){
            path1Count++;
            colCounts1[c]++;
            if(lastCol1 !== -1){
              if(c === lastCol1) straight1++;
              else turns1++;
            }
            lastCol1 = c;
          } else if(state[r][c] === 2){
            path2Count++;
            colCounts2[c]++;
            if(lastCol2 !== -1){
              if(c === lastCol2) straight2++;
              else turns2++;
            }
            lastCol2 = c;
          }
        }
      }
      
      // Check collisions
      for(let r=0;r<ROWS;r++){
        let count = 0;
        for(let c=0;c<COLS;c++){
          if(state[r][c] > 0) count++;
        }
        if(count > 1) collisions += (count - 1);
      }
      
      statsEl.innerHTML = `
        <div class="grid grid-cols-2 gap-2">
          <div class="bg-emerald-900/30 rounded-lg p-3 border border-emerald-700/30">
            <div class="text-emerald-300 text-xs mb-1">Path 1 (Hijau)</div>
            <div class="text-white font-bold text-lg">${path1Count}/${ROWS}</div>
          </div>
          <div class="bg-amber-900/30 rounded-lg p-3 border border-amber-700/30">
            <div class="text-amber-300 text-xs mb-1">Path 2 (Oranye)</div>
            <div class="text-white font-bold text-lg">${path2Count}/${ROWS}</div>
          </div>
        </div>
        
        <div class="flex justify-between items-center bg-slate-900/50 rounded-lg p-3 mt-2">
          <span class="text-slate-400">Collisions:</span>
          <span class="text-${collisions > 0 ? 'red' : 'green'}-400 font-bold text-lg">${collisions}</span>
        </div>
        
        <div class="grid grid-cols-2 gap-2 mt-2">
          <div class="bg-slate-900/50 rounded-lg p-2">
            <div class="text-emerald-400 text-xs mb-1">P1 Turns</div>
            <div class="text-white font-bold">${turns1}</div>
          </div>
          <div class="bg-slate-900/50 rounded-lg p-2">
            <div class="text-amber-400 text-xs mb-1">P2 Turns</div>
            <div class="text-white font-bold">${turns2}</div>
          </div>
        </div>
        
        <div class="bg-slate-900/50 rounded-lg p-3 mt-2">
          <div class="text-slate-400 text-xs mb-2">Row Distribution:</div>
          <div class="grid grid-cols-4 gap-2">
            ${colCounts1.map((count, i) => `
              <div class="text-center">
                <div class="text-emerald-400 text-xs">R${i}</div>
                <div class="text-white font-bold">${count}</div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    function generatePath(pathNum, existingOccupied){
      const prefer = preferMiddle.checked;
      const turns = moreTurns.checked;
      const bal = balanced.checked;
      const avoid = avoidCollision.checked;
      
      let cur = prefer ? (Math.random()<0.5?1:2) : Math.floor(Math.random()*COLS);
      cur = clamp(cur,0,COLS-1);
      
      let path = [];
      let lastMove = 0;
      let straightCount = 0;
      let colUsage = [0,0,0,0];
      
      for(let i=0; i<ROWS; i++){
        if(avoid && existingOccupied[i]?.has(cur)){
          let alternatives = [];
          if(cur > 0 && !existingOccupied[i]?.has(cur-1)) alternatives.push(cur-1);
          if(cur < COLS-1 && !existingOccupied[i]?.has(cur+1)) alternatives.push(cur+1);
          
          if(alternatives.length > 0){
            cur = alternatives[Math.floor(Math.random() * alternatives.length)];
          }
        }
        
        path.push({row: i, col: cur});
        colUsage[cur]++;
        
        if(i === ROWS-1) break;
        
        let possibleMoves = [];
        if(cur > 0) possibleMoves.push(-1);
        possibleMoves.push(0);
        if(cur < COLS-1) possibleMoves.push(1);
        
        let weights = [];
        
        for(let move of possibleMoves){
          let weight = 1.0;
          weight *= (0.5 + Math.random() * 1.5);
          
          if(lastMove !== 0 && move !== 0 && move === -lastMove){
            weight *= 0.15;
          }
          
          if(turns){
            if(move !== 0) weight *= 1.8;
            if(move === 0 && straightCount > 2) weight *= 0.3;
          } else {
            if(move === 0 && straightCount < 4) weight *= 1.5;
          }
          
          if(bal){
            const targetCol = cur + move;
            const avgUsage = (i+1) / COLS;
            if(colUsage[targetCol] < avgUsage) weight *= 1.4;
            if(colUsage[targetCol] > avgUsage * 1.5) weight *= 0.5;
          }
          
          if(avoid && existingOccupied[i+1]?.has(cur + move)){
            weight *= 0.1;
          }
          
          weights.push(weight);
        }
        
        const totalWeight = weights.reduce((a,b)=>a+b, 0);
        let rand = Math.random() * totalWeight;
        let chosenMove = 0;
        
        for(let i=0; i<possibleMoves.length; i++){
          rand -= weights[i];
          if(rand <= 0){
            chosenMove = possibleMoves[i];
            break;
          }
        }
        
        if(chosenMove === 0) straightCount++;
        else straightCount = 0;
        
        lastMove = chosenMove;
        cur = clamp(cur + chosenMove, 0, COLS-1);
      }
      
      return path;
    }

    function generate(){
      state = new Array(ROWS).fill(0).map(()=>new Array(COLS).fill(0));
      
      const path1 = generatePath(1, {});
      const occupied = {};
      for(let cell of path1){
        state[cell.row][cell.col] = 1;
        if(!occupied[cell.row]) occupied[cell.row] = new Set();
        occupied[cell.row].add(cell.col);
      }
      
      const path2 = generatePath(2, occupied);
      for(let cell of path2){
        if(state[cell.row][cell.col] === 0){
          state[cell.row][cell.col] = 2;
        }
      }
      
      render(); 
      updatePreview();
    }

    function clamp(x,a,b){return Math.max(a,Math.min(b,x));}

    document.getElementById('gen').addEventListener('click', generate);

    [preferMiddle, moreTurns, balanced, avoidCollision].forEach(el=>{
      el.addEventListener('change', generate);
    });

    createUI(); 
    generate();
  })();
  </script>
</body>
</html>
